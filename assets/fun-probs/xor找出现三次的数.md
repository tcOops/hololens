---
layout: post
title: xor找出现三次的数
---

题目：数组中有三个数只出现一次，其它的数恰好出现两次，找出这三个数。

分析： 非常经典的一道题目， 先看`弱化版`的题目：

```
数组中有一个数只出现一次，其它的数恰好出现两次，找出这个数。
```

&nbsp;&nbsp;这种题目无非就是排序之后的相邻比较， 或者小范围情况的hash， 或者Map等。
不过算法复杂度始终不是很让人满意， 总是无形中感觉有什么条件没有充分利用。
对， 问题的关键在于： 没有充分利用题目的条件， 而只使用部分条件设计出比较暴力的方法。
其实算法设计的大部分情况下， 都是需要尽可能设计出充分使用各种条件的算法， 无论这些条件是创造性的， 还是题目所给的， 总之，设计的算法使用条件越充分， 越能提高效率。
联想到两个相同的数的运算中，`XOR`这个运算有特殊的结果， 那么尝试将所有数xor，发现结果就是需要的答案。
<br>

```
数组中有两个数只出现一次，其它的数恰好出现两次，找出这两个数。
```

&nbsp;&nbsp;在(1)的基础上进行扩展， 继续往XOR方向思考，但是发现无法直接将他们区分出来。 开始换种角度思考， 异或得到的值肯定不为0， 假设这个结果为x， 那么x肯定存在一个最低的非0位，假设为第k位， 而这个非0位， 肯定就是由要找的那两个数异或得到的结果。 所以，我们找到了一个思路将所有的数分成两大类：第k位为0， 第k位为1. 然后分别对两类数进行异或，就可以得到这两个数。

---
由之前的两个问题铺垫， 可以进行下一步的思考了~！
似乎这类题目都可以从异或角度考虑， 只不过需要稍微进行一点变形。 如果直接将所有数异或， 发现很难找到一个规律将所有数分为两大类， 于是可以这样考虑：
假设需要找的三个数分别为a,b,c， 令 x = a^b^c, 记a^x, b^x, c^x分别为A，B，C， 则：
A^B^C = 0, 这样事情就好办多了， 我们下面的分析仅对A，B，C进行， 显然A,B,C均不相等且不为0（a,b,c互不相等）
因为A^B^C = 0, 那么： 若有一个数在K位上为1， 则其他两个数在K位上一个是1， 一个是0。这样就可以根据第K位的值将所有数字分成两大类。
假设l(x)表示x的出现1的最低位， 那l(A), l(B), l(C)中有两个且只有两个相等。 不妨设之为l(A)与l(B), 那么l(C)>l(A)。于是， `我们对所有的数n都与xXOR一下得到一个新数x`, 并求l(x), 则所有的l(x)的XOR值就是l(C)!
得到l(C) = n之后， 我们发现A, B 在第n位上肯定有一个为0， 一个为1， 那么：我们就可以将数分成两组， 一组第n位上都是0， 一组第n位上都是1， 对都为0的那一组进行XOR， 则可以得到一个数， 然后将之与X进行XOR就得到原来的数。 剩下的问题就是为另外一组的两个数进行分类， 方法同之前两个数的情况。
这样就完美的区分出三个数，且复杂度也可以控制在O(n)级别。

