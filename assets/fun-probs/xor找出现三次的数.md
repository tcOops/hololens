---
layout: post
title: xor找出现三次的数
---

题目：数组中有三个数只出现一次，其它的数恰好出现两次，找出这三个数。

分析： 非常经典的一道题目， 先看弱化版的题目：

```
数组中有一个数只出现一次，其它的数恰好出现两次，找出这个数。
```

这种题目无非就是排序之后的相邻比较， 或者小范围情况的hash， 或者Map等。
不过算法复杂度始终不是很让人满意， 总是无形中感觉有什么条件没有充分利用。
对， 问题的关键在于： 没有充分利用题目的条件， 而只使用部分条件设计出比较暴力的方法。
其实算法设计的大部分情况下， 都是需要尽可能设计出充分使用各种条件的算法， 无论这些条件是创造性的， 还是题目所给的， 总之，设计的算法使用条件越充分， 越能提高效率。
联想到两个相同的数的运算中，`XOR`这个运算有特殊的结果， 那么尝试将所有数xor，发现结果就是需要的答案。

```
数组中有两个数只出现一次，其它的数恰好出现两次，找出这两个数。
```

在(1)的基础上进行扩展， 继续往XOR方向思考，但是发现无法直接将他们区分出来。 开始换种角度思考， 异或得到的值肯定不为0， 假设这个结果为x， 那么x肯定存在一个最低的非0位，假设为第k位， 而这个非0位， 肯定就是由要找的那两个数异或得到的结果。 所以，我们找到了一个思路将所有的数分成两大类：第k位为0， 第k位为1. 然后分别对两类数进行异或，就可以得到这两个数。

---
由之前的两个问题铺垫， 可以进行下一步的思考了~！
